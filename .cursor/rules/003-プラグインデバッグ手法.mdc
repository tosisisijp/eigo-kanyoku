---
description:
globs:
alwaysApply: false
---
# プラグインデバッグ手法

## 目的
- Obsidianプラグインの動作不良を体系的にデバッグする手法を提供
- 文字コード・改行コード問題の特定と解決方法を標準化
- 段階的デバッグによる効率的な問題特定プロセスを確立

## 基本デバッグフロー

### Phase 1: 問題の特定
1. **症状の確認**
   - 期待される動作と実際の動作の差異を明確化
   - エラーメッセージの有無と内容を確認
   - 対象ファイルの基本情報（サイズ、拡張子、エンコーディング）を取得

2. **影響範囲の特定**
   - 特定ファイルのみの問題か、全体的な問題かを判別
   - 類似ファイルでの動作確認
   - プラグイン設定の確認

### Phase 2: 段階的絞り込み
1. **最小限の変更による問題特定**
   - 条件分岐の一時的な無効化（`if (true)` など）
   - ログ出力の追加による実行フロー確認
   - 識別番号付きデバッグログの活用

2. **実行フローの追跡**
   - メソッド呼び出しの開始・終了ログ
   - 変数の値確認
   - 条件分岐の実行パス確認

## 文字コード・改行コード問題の対処法

### 問題パターンの特定
**症状**: 正規表現マッチングの失敗、ファイル認識の不具合

**確認手順**:
1. **PowerShellによる文字コード確認**
```powershell
# ファイル末尾の文字コード確認
$content = [System.IO.File]::ReadAllBytes("ファイル名.md")
$endIndex = $content.Length - 10  # 末尾10バイトを確認
for ($i = $endIndex; $i -lt $content.Length; $i++) {
    $char = $content[$i]
    $hex = "{0:X2}" -f $char
    $ascii = if ($char -ge 32 -and $char -le 126) { [char]$char } else { "." }
    Write-Host "$i : $hex ($ascii)"
}
```

2. **改行コード混在の確認**
```powershell
# ファイル全体の改行コード確認
$content = Get-Content "ファイル名.md" -Raw
$lf = ($content | Select-String -Pattern "`n" -AllMatches).Matches.Count
$crlf = ($content | Select-String -Pattern "`r`n" -AllMatches).Matches.Count
Write-Host "LF: $lf, CRLF: $crlf"
```

### 典型的な問題パターン

#### パターン1: 改行コード混在
**問題**: ファイル全体はLF、特定箇所のみCRLF
**症状**: 正規表現 `/^START\n([\s\S]*?\n)END/gm` が失敗
**解決**: PowerShellでの完全書き直し（LF統一）

#### パターン2: 不可視文字の混入
**問題**: ENDマーカー後のスペース（`END `）
**症状**: END境界の認識失敗
**解決**: 不可視文字の除去

#### パターン3: エンコーディング不整合
**問題**: UTF-8 BOM、Shift-JIS混在
**症状**: ファイル読み込み時の文字化け
**解決**: エンコーディング統一

## デバッグログの効果的な活用

### 識別番号付きログ
```javascript
// 実行フロー追跡用のログ
console.log("DEBUG-1: メソッド開始前");
// 処理...
console.log("DEBUG-2: ループ開始直後");
// ループ処理...
console.log("DEBUG-3A: 条件A通過");
// 条件分岐...
console.log("DEBUG-4: メソッド終了直後");
```

### 変数値の確認
```javascript
// 重要な変数の値を確認
console.log("変数名:", JSON.stringify(変数, null, 2));
console.log("配列長:", 配列.length);
console.log("正規表現マッチ結果:", 正規表現.exec(文字列));
```

## 正規表現デバッグの手法

### マッチング失敗時の確認項目
1. **対象文字列の確認**
   - 実際の文字列内容をログ出力
   - 改行コード、空白文字の可視化
   - 文字列長の確認

2. **正規表現の段階的テスト**
   - 単純なパターンから複雑なパターンへ
   - フラグ（g, m, s）の影響確認
   - エスケープ文字の適切性確認

3. **境界条件の確認**
   - 行頭・行末の挙動
   - 複数行にまたがるマッチング
   - 貪欲・非貪欲マッチングの影響

## プラグイン固有の考慮事項

### Obsidian_to_Ankiプラグインの場合
1. **ファイルハッシュ比較の回避**
   - 初期デバッグ時は `if (true)` で全ファイル処理
   - 問題特定後に適切な条件に戻す

2. **scanFile()メソッドの段階的確認**
   - setupScan() の実行確認
   - scanNotes() の実行確認
   - 正規表現マッチングの実行確認
   - 結果統合の実行確認

3. **ID管理の注意点**
   - 既存IDの保護（変更・削除禁止）
   - 新規IDの自動生成待ち
   - ID重複の回避

## 解決後の標準化

### ルール・ドキュメントへの反映
1. **問題パターンの文書化**
   - 症状・原因・解決方法の3点セット
   - 再現手順の明記
   - 予防策の提示

2. **チェックリスト化**
   - 品質基準への組み込み
   - 定期確認項目への追加
   - 自動化可能な項目の特定

3. **ツール・スクリプト化**
   - 確認作業の自動化
   - 標準的な修正手順のスクリプト化
   - エラー検出の自動化

## 予防策

### ファイル作成時の注意点
1. **改行コードの統一**
   - プロジェクト全体での改行コード統一
   - エディタ設定の確認
   - Git設定での改行コード管理

2. **文字エンコーディングの統一**
   - UTF-8（BOMなし）の徹底
   - ファイル保存時の確認
   - 自動変換設定の活用

3. **不可視文字の管理**
   - エディタでの不可視文字表示
   - 末尾空白の自動除去
   - タブ・スペースの統一

## 関連ツール・コマンド

### PowerShell
- `[System.IO.File]::ReadAllBytes()`: バイナリレベルでの文字確認
- `Get-Content -Raw`: ファイル全体の一括読み込み
- `Select-String -Pattern`: 正規表現による検索

### Git
- `git config core.autocrlf`: 改行コード自動変換設定
- `git ls-files --eol`: ファイル別改行コード確認

### Obsidian
- プラグイン開発者ツール（Ctrl+Shift+I）
- コンソールログの確認
- ファイルメタデータの確認

## 成功事例

### Obsidian_to_Ankiプラグイン デバッグ事例
**問題**: cut-back-削減する.mdファイルが認識されない
**原因**: ENDマーカー後のスペース + 改行コード混在（`END ` + LF）
**解決**: PowerShellでの完全書き直し（LF統一）
**結果**: プラグインが正常にID自動生成（`<!--ID: 1750490949194-->`）

**学んだ教訓**:
1. 文字コードレベルでの確認の重要性
2. 段階的デバッグによる効率的な問題特定
3. 最小限の変更による影響範囲の限定
4. 解決後のルール化による再発防止

## 関連ファイル
- [[202-Obsidian_to_Anki独自形式管理.mdc]] - Obsidian_to_Anki固有の品質基準
- [[110-PowerShell操作管理.mdc]] - プロジェクト共通操作・基本処理（旧103統合）
- [[203-Obsidian_to_Anki専用PowerShell操作.mdc]] - Obsidian_to_Anki専用操作・検証・修正
- [[004-PowerShell操作ガイド.mdc]] - 汎用PowerShell操作技術
- [[001-AI実装ガイドライン.mdc]] - AI実装時の基本制約
- [[105-検証・品質管理.mdc]] - 品質管理プロセス
